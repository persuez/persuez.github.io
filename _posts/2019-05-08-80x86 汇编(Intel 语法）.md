---
published: true
tags:
  - 80x86 CPU
author: persuez
---
### 比较
比较是基于减法的指令，但是减法的结果并不会存储，比较的结果会根据减法的结果来设置  **FLAGS** 寄存器。执行指令 `cmp vleft, vright`，会先计算 `vleft - vright`，然后按照下面的规则设置 flag 位:
  - 对于无符号整数：**FLAGS** 寄存器中有两个位是重要的：ZF(zero flag) 和 CF(carry flag)，其中 ZF 是在差值为 0 时被设置（值为 1），CF 是在减法发生借位时设置。即，如果 `vleft = vright`，ZF 将被设置为 1, CF 为 0；如果 `vleft > vright`，ZF 为 0，CF 为 0；如果 `vleft < vright`，ZF 为 0, CF 为 1。
  - 对于有符号整数：**FLAGS** 寄存器中有三个位是重要的：ZF，OF(overflow flag) 和 SF(sign flag)，其中 ZF 是在差值为 0 时被设置，OF 是在减法发生溢出(overflow 或 underflow)时被设置，SF 是减法结果为负数时被设置。要理解接下来的内容，必须要知道什么情况下会发生溢出。当长度为n位的两个二进制数经过加减法器运算，得到的长度为n位的结果不是正确值时，我们说发生溢出。<sup>[[1]](#reference1)</sup>

### 参考文献
<span id="reference1"><span>1. [算数溢出](https://zh.wikipedia.org/wiki/%E7%AE%97%E8%A1%93%E6%BA%A2%E5%87%BA)
