---
published: true
layout: post
author: persuez
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
  - 计算理论 NFA 正则操作
---
#### 以下证明均用NFA证明，以下证明均只说证明思路，没有严格的数学论证。

## 正则语言在并操作中是封闭的。(The class of regular languages is closed under the union operation.)
思路：我们有两个正则语言$A_1$和$A_2$，并且想要证明$A_1 \cup A_2$也是正则语言。我们证明的思路是有两个NFA$N_1$和$N_2$分别识别语言$A_1$和$A_2$,我们现在要构造一个NFA$N$来识别$A_1 \cup A_2$。

我们要设计$N$使得：如果$N_1$或$N_2$接受了输入，那么机器$N$也要接受该输入。在NFA中，要构造这种机器是相当容易的，只要新增一个开始状态，并用$\epsilon$分别“映射”到$N_1$和$N_2$的开始状态就可以了。下图可以直白的看出构造：
![union图](https://ws1.sinaimg.cn/large/006aPatNgy1fs3v8cg8htj30kd0dtgml.jpg)

## 正则语言在连接操作中是封闭的。(The class of regular languages is closed under the concatenation operation.)
思路：我们有两个正则语言$A_1$和$A_2$，并且想要证明$A_1 \circ A_2$也是正则语言。我们证明的思路是有两个NFA$N_1$和$N_2$分别识别语言$A_1$和$A_2$,我们现在要构造一个NFA$N$来识别$A_1 \circ A_2$。

我们要设计$N$使得：如果$N_1$或$N_2$接受了输入，那么机器$N$也要接受该输入。在NFA中，要构造这种机器是相当容易的，只要将$N_1$的所有接受状态变为普通状态，通过$\epsilon$“映射”到$N_2$的开始状态即可。下图可以直白的看出构造：
![concatenation图](https://ws1.sinaimg.cn/large/006aPatNgy1fs3vseebjkj30iz0cq3zb.jpg)

## 正则语言在闭包操作中是封闭的。(The class of regular languages is closed under the star operation.)
思路：我们有正则语言$A_1$，并且想要证明$A_1^\star$也是正则语言。我们证明的思路是有一个NFA$N_1$识别$A_1$,我们将修改它使其能够识别$A_1^\star$。
