---
published: true
layout: post
subtitle: NFA和DFA等价转换
author: persuez
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags:
  - 计算理论 NFA DFA
---
# 每个NFA都有一个等价的DFA

### 证明思路（NFA转DFA的方法）
我们要证明NFA和DFA等价，因为DFA是NFA的一般化，所以NFA一定可以模拟DFA，因此我们需要做的是用DFA模拟NFA。因为NFA在当前状态读到一个字符后可以有多条路可以走,所以模拟该NFA的DFA将有$2^k$个状态，每个状态都是NFA状态集的幂集的一个元素。具体操作在证明过程中。

### 证明
假设我们有一台NFA $N=(Q, \sum, \delta, q_0, F)$识别语言$A$,现在我们要构造一台DFA $M=(Q^{\'}, \sum, \delta^{\'}, q_0^{\'}, F^{\'})$识别语言$A$。在完整构造$M$之前，我们先假设$N$没有$\epsilon-move$。之后再考虑$epsilon-move$的情况。

1. $Q^{\'}=P(Q)$,这个条件是理解这个构造的关键，如果理解了1和下面的3，那基本整个构造就理解了。如果不能理解，那可以先放下，先看后面具体的例子。
2. 注意$M$和$N$中的字符表是一样的（此时没有考虑$\epsilon-move$）。
3. $\delta^{\'}(R, a)=\lbrace\ q \in Q \mid\ q \in \delta(r, a),\ r \in R\ \rbrace$,其中$R \in Q^{\'}$。我们知道，$R$是$M$的一个状态，它也是$N$的一些状态的集合。当$M$在状态$R$遇到字符$a$时，那么我们要记录$N$中处于集合$R$中的所有元素时，$N$向哪个状态转移。所以上述转移函数也可以写为$$\delta^\'(R, a)=\bigcup_{r \in R}\delta(r, a)$$
